using System;
using System.IO;
using Lextm.SharpSnmpLib;

namespace Lextm.SharpSnmpPro.Mib.Registry
{
    public static class ObjectTreeExtensions
    {
        public static void GenerateSourceFiles(this ObjectTree tree, string outputFolder)
        {
            if (!Directory.Exists(outputFolder))
            {
                Directory.CreateDirectory(outputFolder);
            }

            var project = Path.Combine(outputFolder, "Objects.csproj");
            if (!File.Exists(project))
            {
                File.WriteAllText(project, Properties.Resources.Objects);
            }

            foreach (var module in tree.LoadedModules)
            {
                if (module.Objects.Count == 0)
                {
                    continue;
                }

                module.Generate(outputFolder);
            }
        }
    }

    public static class ModuleExtensions
    {
        public static void Generate(this Module module, string folder)
        {
            if (module.Objects.Count == 0)
            {
                return;
            }

            var fileName = Path.Combine(folder, module.Name + ".Generated.cs");
            var customName = Path.Combine(folder, module.Name + ".cs");
            using (var custom = File.Exists(customName) ? null : new StreamWriter(customName, false))
            using (var generated = new StreamWriter(fileName, false))
            {
                generated.WriteLine("// Generated by #SNMP MIB Compiler Pro {0}", System.Reflection.Assembly.GetExecutingAssembly().GetName().Version);
                generated.WriteLine("// IMPORTANT: This file is overwritten during compilation, so you should not modify it manually.");
                generated.WriteLine("// Original file name is {0}", module.FileName);
                generated.WriteLine("using System;");
                generated.WriteLine("using System.Collections.Generic;");
                generated.WriteLine("using Lextm.SharpSnmpLib;");
                generated.WriteLine("using Samples.Pipeline;");
                generated.WriteLine("// using Lextm.SharpSnmpPro.Mib; // TODO: Uncomment if syntax validation is required.");
                generated.WriteLine();
                generated.WriteLine("namespace {0}", module.Name.Replace('-', '_'));
                generated.WriteLine("{");

                custom?.WriteLine("// Initially generated by #SNMP MIB Compiler Pro {0}", System.Reflection.Assembly.GetExecutingAssembly().GetName().Version);
                custom?.WriteLine("// IMPORTANT: This file can be modified, but won't be updated by the compiler again.");
                custom?.WriteLine("// Original file name is {0}", module.FileName);
                custom?.WriteLine("using System;");
                custom?.WriteLine("using System.Collections.Generic;");
                custom?.WriteLine("using Lextm.SharpSnmpLib;");
                custom?.WriteLine("using Samples.Pipeline;");
                custom?.WriteLine("// using Lextm.SharpSnmpPro.Mib; // TODO: Uncomment if syntax validation is required.");
                custom?.WriteLine();
                custom?.WriteLine("namespace {0}", module.Name.Replace('-', '_'));
                custom?.WriteLine("{");

                foreach (ObjectTypeMacro obj in module.Objects)
                {
                    obj.Generate(generated, custom);
                }

                generated.WriteLine("}");
                custom?.WriteLine("}");
            }
        }
    }

    public static class ObjectTypeMacroExtensions
    {
        public static void Generate(this ObjectTypeMacro macro, StreamWriter generated, StreamWriter custom)
        {
            if (macro.Status == EntityStatus.Deprecated || macro.Status == EntityStatus.Obsolete)
            {
                return;
            }

            if (macro.Type == DefinitionType.Entry)
            {
                return;
            }

            generated.WriteLine();
            custom?.WriteLine();
            var className = macro.Name.Replace('-', '_');
            var id = Lextm.SharpSnmpLib.ObjectIdentifier.Convert(macro.GetObjectIdentifier());
            if (macro.Type == DefinitionType.Table)
            {
                generated.WriteLine("    /// <remarks>");
                generated.WriteLine("    /// * ID:");
                generated.WriteLine("    ///   {0}", id);
                generated.WriteLine("    /// * Max access:");
                generated.WriteLine("    ///   {0}", ToString(macro.MibAccess));
                generated.WriteLine("    /// * Status:");
                generated.WriteLine("    ///   {0}", macro.Status.ToStatusString());
                if (!string.IsNullOrEmpty(macro.Description))
                {
                    generated.WriteLine("    /// * Description:");
                    using (var reader = new StringReader(macro.Description))
                    {
                        string line;
                        while ((line = reader.ReadLine()) != null)
                        {
                            generated.WriteLine("    ///   {0}", line);
                        }

                        reader.Close();
                    }
                }

                if (macro.Entry != null)
                {
                    if (macro.Entry.IndexList != null)
                    {
                        generated.WriteLine("    /// * Indexes:");
                        foreach (var index in macro.Entry.IndexList)
                        {
                            generated.WriteLine("    ///   {0}", index.Type); // TODO: generate proper string.
                        }
                    }

                    if (macro.Entry.Augments != null)
                    {
                        generated.WriteLine("    /// * Augments:");
                        generated.WriteLine("    ///   {0}", macro.Entry.Augments.Type); // TODO: generate proper string.
                    }
                }

                generated.WriteLine("    /// </remarks>");
                generated.WriteLine("    public sealed partial class {0} : TableObject", className);
                generated.WriteLine("    {");
                generated.WriteLine("        private readonly IList<ScalarObject> _elements = new List<ScalarObject>();");
                generated.WriteLine();
                generated.WriteLine("        protected override IEnumerable<ScalarObject> Objects");
                generated.WriteLine("        {");
                generated.WriteLine("            get { return _elements; }");
                generated.WriteLine("        }");
                generated.WriteLine("    }");

                custom?.WriteLine("    partial class {0}", className);
                custom?.WriteLine("    {");
                custom?.WriteLine("        public {0}()", className);
                custom?.WriteLine("        {");
                custom?.WriteLine("            // TODO: add rows and columns here.");
                custom?.WriteLine("        }");
                custom?.WriteLine("    }");
                return;
            }

            generated.WriteLine("    /// <remarks>");
            generated.WriteLine("    /// * ID:");
            generated.WriteLine("    ///   {0}", id);
            generated.WriteLine("    /// * Max access:");
            generated.WriteLine("    ///   {0}", ToString(macro.MibAccess));
            generated.WriteLine("    /// * Status:");
            generated.WriteLine("    ///   {0}", macro.Status.ToStatusString());
            generated.WriteLine("    /// * Description:");
            if (!string.IsNullOrEmpty(macro.Description))
            {
                using (var reader = new StringReader(macro.Description))
                {
                    string line;
                    while ((line = reader.ReadLine()) != null)
                    {
                        generated.WriteLine("    ///   {0}", line);
                    }

                    reader.Close();
                }
            }

            generated.WriteLine("    /// </remarks>");
            generated.WriteLine("    public sealed partial class {0} : ScalarObject", className);
            generated.WriteLine("    {");
            generated.WriteLine(
                macro.Type == DefinitionType.Scalar
                    ? "        public {0}() : base(\"{1}.0\")"
                    : "        public {0}(params string[] indexes) : base(\"{1}.{{0}}\", string.Join(indexes))",
                className,
                id);
            generated.WriteLine("        {");
            generated.WriteLine("        }");
            generated.WriteLine("    }");

            custom?.WriteLine("    partial class {0}", className);
            custom?.WriteLine("    {");
            custom?.WriteLine("        // TODO: add new constructors here.");
            custom?.WriteLine();
            custom?.WriteLine("        private ISnmpData _data = {0}; // TODO: remove initial assignment if you want to do it in constructors.", Default(macro.ResolvedSyntax.GetLastType()));
            custom?.WriteLine();
            custom?.WriteLine("        public override ISnmpData Data");
            custom?.WriteLine("        {");
            custom?.WriteLine("            get { return _data; }");
            if (macro.MibAccess == Access.ReadOnly)
            {
                custom?.WriteLine("            set { throw new AccessFailureException(); }");
            }
            else
            {
                custom?.WriteLine(
                    "            // TODO: Use ObjectRegistryBase.Verify(\"{0}\", \"{1}\", value) to validate data",
                    macro.Module.Name,
                    macro.Name);
                custom?.WriteLine("            set { _data = value; }");
            }
            custom?.WriteLine("        }");
            custom?.WriteLine("    }");
        }

        internal static string Default(ISmiType type)
        {
            if (type is IntegerType)
            {
                return "new Integer32(0)";
            }

            if (type is Counter32Type)
            {
                return "new Counter32(0)";
            }

            if (type is Counter64Type)
            {
                return "new Counter64(0)";
            }

            if (type is Gauge32Type)
            {
                return "new Gauge32(0)";
            }

            if (type is TimeTicksType)
            {
                return "new TimeTicks(0)";
            }

            if (type is OctetStringType)
            {
                return "OctetString.Empty";
            }

            if (type is ObjectIdentityMacro || type is ObjectIdentifierMacro)
            {
                return "new ObjectIdentifier(\".0.0\")";
            }

            if (type is IpAddressType)
            {
                return "new IP(\"127.0.0.1\")";
            }

            return "null";
        }

        private static string ToString(Access access)
        {
            switch (access)
            {
                case Access.ReadOnly:
                    return "read-only";
                case Access.ReadWrite:
                    return "read-write";
                case Access.WriteOnly:
                    return "write-only";
                case Access.ReadCreate:
                    return "read-create";
                case Access.NotAccessible:
                    return "not-accessible";
                case Access.AccessibleForNotify:
                    return "accessible-for-notify";
                case Access.NotImplemented:
                    return "not-implemented";
                default:
                    throw new ArgumentOutOfRangeException(nameof(access));
            }
        }
    }
}
