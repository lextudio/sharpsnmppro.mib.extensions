using System;
using System.IO;

namespace Lextm.SharpSnmpPro.Mib.Registry
{
    public static class ObjectTreeExtensions
    {
        public static void GenerateSourceFiles(this ObjectTree tree, string outputFolder)
        {
            if (!Directory.Exists(outputFolder))
            {
                Directory.CreateDirectory(outputFolder);
            }

            File.WriteAllText(Path.Combine(outputFolder, "Objects.csproj"), Properties.Resources.Objects);
            foreach (var module in tree.LoadedModules)
            {
                if (module.Objects.Count == 0)
                {
                    continue;
                }

                module.Generate(outputFolder);
            }
        }
    }

    public static class ModuleExtensions
    {
        public static void Generate(this Module module, string folder)
        {
            if (module.Objects.Count == 0)
            {
                return;
            }

            using (var file = new StreamWriter(Path.Combine(folder, module.Name + ".cs")))
            {
                file.WriteLine("// Generated by #SNMP MIB Compiler Pro {0}", System.Reflection.Assembly.GetExecutingAssembly().GetName().Version);
                file.WriteLine("// Original file name is {0}", module.FileName);
                file.WriteLine("using System;");
                file.WriteLine("using System.Collections.Generic;");
                file.WriteLine("using Lextm.SharpSnmpLib;");
                file.WriteLine("using Lextm.SharpSnmpLib.Pipeline;");
                file.WriteLine("// using Lextm.SharpSnmpPro.Mib; // TODO: Uncomment if syntax validation is required.");
                file.WriteLine();
                file.WriteLine("namespace {0}", module.Name.Replace('-', '_'));
                file.WriteLine("{");

                foreach (ObjectTypeMacro obj in module.Objects)
                {
                    obj.Generate(file);
                }

                file.WriteLine("}");
            }
        }
    }

    public static class ObjectTypeMacroExtensions
    {
        public static void Generate(this ObjectTypeMacro macro, StreamWriter file)
        {
            if (macro.Status == EntityStatus.Deprecated || macro.Status == EntityStatus.Obsolete)
            {
                return;
            }

            if (macro.Type == DefinitionType.Entry)
            {
                return;
            }

            file.WriteLine();
            var className = macro.Name.Replace('-', '_');
            var id = SharpSnmpLib.ObjectIdentifier.Convert(macro.GetObjectIdentifier());
            if (macro.Type == DefinitionType.Table)
            {
                file.WriteLine("    /// <remarks>");
                file.WriteLine("    /// * ID:");
                file.WriteLine("    ///   {0}", id);
                file.WriteLine("    /// * Max access:");
                file.WriteLine("    ///   {0}", ToString(macro.MibAccess));
                file.WriteLine("    /// * Status:");
                file.WriteLine("    ///   {0}", macro.Status.ToStatusString());
                if (!string.IsNullOrEmpty(macro.Description))
                {
                    file.WriteLine("    /// * Description:");
                    using (var reader = new StringReader(macro.Description))
                    {
                        string line;
                        while ((line = reader.ReadLine()) != null)
                        {
                            file.WriteLine("    ///   {0}", line);
                        }

                        reader.Close();
                    }
                }

                if (macro.Entry != null)
                {
                    if (macro.Entry.IndexList != null)
                    {
                        file.WriteLine("    /// * Indexes:");
                        foreach (var index in macro.Entry.IndexList)
                        {
                            file.WriteLine("    ///   {0}", index.Type); // TODO: generate proper string.
                        }
                    }

                    if (macro.Entry.Augments != null)
                    {
                        file.WriteLine("    /// * Augments:");
                        file.WriteLine("    ///   {0}", macro.Entry.Augments.Type); // TODO: generate proper string.
                    }
                }

                file.WriteLine("    /// </remarks>");
                file.WriteLine("    public sealed class {0} : TableObject", className);
                file.WriteLine("    {");
                file.WriteLine("        private readonly IList<ScalarObject> _elements = new List<ScalarObject>();");
                file.WriteLine();
                file.WriteLine("        protected override IEnumerable<ScalarObject> Objects");
                file.WriteLine("        {");
                file.WriteLine("            get { return _elements; }");
                file.WriteLine("        }");
                file.WriteLine("    }");
                return;
            }

            file.WriteLine("    /// <remarks>");
            file.WriteLine("    /// * ID:");
            file.WriteLine("    ///   {0}", id);
            file.WriteLine("    /// * Max access:");
            file.WriteLine("    ///   {0}", ToString(macro.MibAccess));
            file.WriteLine("    /// * Status:");
            file.WriteLine("    ///   {0}", macro.Status.ToStatusString());
            file.WriteLine("    /// * Description:");
            if (!string.IsNullOrEmpty(macro.Description))
            {
                using (var reader = new StringReader(macro.Description))
                {
                    string line;
                    while ((line = reader.ReadLine()) != null)
                    {
                        file.WriteLine("    ///   {0}", line);
                    }

                    reader.Close();
                }
            }

            file.WriteLine("    /// </remarks>");
            file.WriteLine("    public sealed class {0} : ScalarObject", className);
            file.WriteLine("    {");
            file.WriteLine("        private ISnmpData _data = {0};", Default(macro.ResolvedSyntax.GetLastType()));
            file.WriteLine();
            file.WriteLine(
                macro.Type == DefinitionType.Scalar
                    ? "        public {0}() : base(new ObjectIdentifier(\"{1}.0\"))"
                    : "        public {0}(int index) : base(\"{1}.{{0}}\", index)",
                className,
                id);
            file.WriteLine("        {");
            file.WriteLine("        }");
            file.WriteLine();
            file.WriteLine("        public override ISnmpData Data");
            file.WriteLine("        {");
            file.WriteLine("            get { return _data; }");
            if (macro.MibAccess == Access.ReadOnly)
            {
                file.WriteLine("            set { throw new AccessFailureException(); }");
            }
            else
            {
                file.WriteLine(
                    "            // TODO: Use ObjectRegistryBase.Verify(\"{0}\", \"{1}\", value) to validate data",
                    macro.Module.Name,
                    macro.Name);
                file.WriteLine("            set { _data = value; }");
            }
            file.WriteLine("        }");
            file.WriteLine("    }");
        }

        internal static string Default(ISmiType type)
        {
            if (type is IntegerType)
            {
                return "new Integer32(0)";
            }

            if (type is Counter32Type)
            {
                return "new Counter32(0)";
            }

            if (type is Counter64Type)
            {
                return "new Counter64(0)";
            }

            if (type is Gauge32Type)
            {
                return "new Gauge32(0)";
            }

            if (type is TimeTicksType)
            {
                return "new TimeTicks(0)";
            }

            if (type is OctetStringType)
            {
                return "OctetString.Empty";
            }

            if (type is ObjectIdentityMacro || type is ObjectIdentifierMacro)
            {
                return "new ObjectIdentifier(\".0.0\")";
            }

            if (type is IpAddressType)
            {
                return "new IP(\"127.0.0.1\")";
            }

            return "null";
        }

        private static string ToString(Access access)
        {
            switch (access)
            {
                case Access.ReadOnly:
                    return "read-only";
                case Access.ReadWrite:
                    return "read-write";
                case Access.WriteOnly:
                    return "write-only";
                case Access.ReadCreate:
                    return "read-create";
                case Access.NotAccessible:
                    return "not-accessible";
                case Access.AccessibleForNotify:
                    return "accessible-for-notify";
                case Access.NotImplemented:
                    return "not-implmented";
                default:
                    throw new ArgumentOutOfRangeException(nameof(access));
            }
        }
    }
}
