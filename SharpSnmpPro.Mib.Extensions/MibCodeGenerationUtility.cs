using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Lextm.SharpSnmpLib;
using Lextm.SharpSnmpPro.Mib;
using Lextm.SharpSnmpPro.Mib.Registry;

namespace Lextm.SharpSnmpPro.Mib.Extensions
{
    /// <summary>
    /// Shared utility class for MIB code generation.
    /// Used by both SharpSnmpPro.Mib.Extensions and MibSourceGenerator.
    /// </summary>
    public static class MibCodeGenerationUtility
    {
        /// <summary>
        /// Generates the common module code header for a module.
        /// </summary>
        /// <param name="sb">The StringBuilder to append to.</param>
        /// <param name="module">The Module to generate code for.</param>
        /// <param name="version">The version string to include in the header.</param>
        /// <param name="isGeneratedFile">Whether this is a generated file (true) or customizable file (false).</param>
        public static void GenerateModuleHeader(StringBuilder sb, Module module, string version, bool isGeneratedFile)
        {
            if (isGeneratedFile)
            {
                sb.AppendLine($"// Generated by {version}");
                sb.AppendLine("// IMPORTANT: This file is overwritten during compilation, so you should not modify it manually.");
            }
            else
            {
                sb.AppendLine($"// Initially generated by {version}");
                sb.AppendLine("// IMPORTANT: This file can be modified, but won't be updated by the generator again once created.");
            }
            
            sb.AppendLine($"// Original file name is {module.FileName}");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using Lextm.SharpSnmpLib;");
            sb.AppendLine("using Samples.Pipeline;");
            
            if (!isGeneratedFile)
            {
                sb.AppendLine("using System.Linq;");
                sb.AppendLine("using System.Net.NetworkInformation;");
            }
            
            sb.AppendLine("// using Lextm.SharpSnmpPro.Mib; // TODO: Uncomment if syntax validation is required.");
            sb.AppendLine();
            sb.AppendLine($"namespace {module.Name.Replace("-", "_")}");
            sb.AppendLine("{");
        }

        /// <summary>
        /// Generates the module code for a Module.
        /// </summary>
        /// <param name="module">The Module to generate code for.</param>
        /// <param name="version">The version string to include in the header.</param>
        /// <param name="isGeneratedFile">Whether this is a generated file (true) or customizable file (false).</param>
        /// <returns>The generated code as a string.</returns>
        public static string GenerateModuleCode(Module module, string version, bool isGeneratedFile)
        {
            var sb = new StringBuilder();
            GenerateModuleHeader(sb, module, version, isGeneratedFile);

            foreach (var obj in module.Objects)
            {
                if (isGeneratedFile)
                {
                    GenerateObjectCode(sb, obj);
                }
                else
                {
                    GenerateCustomObjectCode(sb, obj);
                }
            }

            sb.AppendLine("}");
            return sb.ToString();
        }

        /// <summary>
        /// Generates code for an object in a module's generated file.
        /// </summary>
        /// <param name="sb">The StringBuilder to append to.</param>
        /// <param name="obj">The object to generate code for.</param>
        public static void GenerateObjectCode(StringBuilder sb, IEntity obj)
        {
            if (obj is ObjectTypeMacro ot) // Check for ObjectTypeMacro (scalar or column objects)
            {
                if (ot.Type == DefinitionType.Entry)
                {
                    return; // Skip Entry types
                }

                var oid = ObjectIdentifier.Convert(ot.GetObjectIdentifier());
                sb.AppendLine();
                sb.AppendLine("    /// <remarks>");
                sb.AppendLine($"    /// * ID:");
                sb.AppendLine($"    ///   {oid}");
                sb.AppendLine("    /// * Max access:");
                sb.AppendLine($"    ///   {ot.MibAccess.ToString().ToLowerInvariant()}");
                sb.AppendLine("    /// * Status:");
                sb.AppendLine($"    ///   {ot.Status.ToString().ToLowerInvariant()}");
                if (!string.IsNullOrEmpty(ot.Description))
                {
                    sb.AppendLine("    /// * Description:");
                    foreach (var line in ot.Description.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries))
                    {
                        sb.AppendLine($"    ///   \"{line.Trim()}\"");
                    }
                }

                if (ot.Type == DefinitionType.Table && ot.Entry != null)
                {
                    if (ot.Entry.IndexList != null)
                    {
                        sb.AppendLine("    /// * Indexes:");
                        foreach (var index in ot.Entry.IndexList)
                        {
                            sb.AppendLine($"    ///   {index.Type}"); // TODO: generate proper string.
                        }
                    }

                    if (ot.Entry.Augments != null)
                    {
                        sb.AppendLine("    /// * Augments:");
                        sb.AppendLine($"    ///   {ot.Entry.Augments.Type}"); // TODO: generate proper string.
                    }
                }

                sb.AppendLine("    /// </remarks>");

                // Determine if this is a scalar or tabular object
                var parentType = ot.Parent?.GetType().Name ?? string.Empty;
                if (ot.Type == DefinitionType.Table)
                {
                    // Table object
                    sb.AppendLine($"    public sealed partial class {ot.Name} : TableObject");
                    sb.AppendLine("    {");
                    sb.AppendLine("        private readonly IList<ScalarObject> _elements = new List<ScalarObject>();");
                    sb.AppendLine();
                    sb.AppendLine("        protected override IEnumerable<ScalarObject> Objects");
                    sb.AppendLine("        {");
                    sb.AppendLine("            get { return _elements; }");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine($"        public {ot.Name}()");
                    sb.AppendLine("        {");
                    sb.AppendLine("            OnCreate();");
                    sb.AppendLine("        }");
                    sb.AppendLine("    }");
                }
                else
                {
                    // Scalar object
                    sb.AppendLine($"    public sealed partial class {ot.Name} : ScalarObject");
                    sb.AppendLine("    {");
                    if (ot.Type == DefinitionType.Scalar)
                    {
                        sb.AppendLine($"        public {ot.Name}() : base(\"{oid}.0\")");
                    }
                    else
                    {
                        sb.AppendLine($"        public {ot.Name}(params string[] indexes) : base(\"{oid}.{{0}}\", string.Join('.', indexes))");
                    }
                    sb.AppendLine("        {");
                    sb.AppendLine("            OnCreate();");
                    sb.AppendLine("        }");
                    sb.AppendLine("    }");
                }
            }
        }

        /// <summary>
        /// Generates code for an object in a module's customizable file.
        /// </summary>
        /// <param name="sb">The StringBuilder to append to.</param>
        /// <param name="obj">The object to generate code for.</param>
        public static void GenerateCustomObjectCode(StringBuilder sb, IEntity obj)
        {
            if (obj is ObjectTypeMacro ot)
            {
                if (ot.Type == DefinitionType.Entry)
                {
                    return;
                }
                else if (ot.Type == DefinitionType.Table)
                {
                    sb.AppendLine();
                    sb.AppendLine($"    partial class {obj.Name}");
                    sb.AppendLine("    {");
                    sb.AppendLine("        void OnCreate()");
                    sb.AppendLine("        {");
                    sb.AppendLine("            // TODO: Add table entries here");
                    sb.AppendLine("        }");
                    sb.AppendLine("    }");
                    return;
                }

                sb.AppendLine();
                sb.AppendLine($"    partial class {obj.Name}");
                sb.AppendLine("    {");
                sb.AppendLine($"        private ISnmpData _data = {(ot.ResolvedSyntax != null ? Default(ot.ResolvedSyntax.GetLastType()) : "new Integer32(0)")}; // TODO: remove initial assignment if you want to do it in constructors.");
                sb.AppendLine();
                sb.AppendLine("        void OnCreate()");
                sb.AppendLine("        {");
                sb.AppendLine("            // TODO: initialization here");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.AppendLine("        public override ISnmpData Data");
                sb.AppendLine("        {");
                sb.AppendLine("            get { return _data; }");

                if (ot.MibAccess == Access.ReadOnly)
                {
                    sb.AppendLine("            set { throw new AccessFailureException(); }");
                }
                else
                {
                    sb.AppendLine($"            // TODO: Use ObjectRegistryBase.Verify(\"{obj.Module.Name}\", \"{obj.Name}\", value) to validate data");
                    sb.AppendLine("            set { _data = value; }");
                }

                sb.AppendLine("        }");
                sb.AppendLine("    }");
            }
        }

        /// <summary>
        /// Gets the default value for a type.
        /// </summary>
        /// <param name="type">The type to get the default value for.</param>
        /// <returns>A string representing the default value.</returns>
        public static string Default(ISmiType type)
        {
            if (type is IntegerType)
            {
                return "new Integer32(0)";
            }

            if (type is Counter32Type)
            {
                return "new Counter32(0)";
            }

            if (type is Counter64Type)
            {
                return "new Counter64(0)";
            }

            if (type is Gauge32Type)
            {
                return "new Gauge32(0)";
            }

            if (type is TimeTicksType)
            {
                return "new TimeTicks(0)";
            }

            if (type is OctetStringType)
            {
                return "OctetString.Empty";
            }

            if (type is ObjectIdentityMacro || type is ObjectIdentifierMacro)
            {
                return "new ObjectIdentifier(\".0.0\")";
            }

            if (type is IpAddressType)
            {
                return "new IP(\"127.0.0.1\")";
            }

            return "null";
        }

        /// <summary>
        /// Converts an access enum to a string.
        /// </summary>
        /// <param name="access">The access enum value.</param>
        /// <returns>A string representation of the access.</returns>
        public static string AccessToString(Access access)
        {
            switch (access)
            {
                case Access.ReadOnly:
                    return "read-only";
                case Access.ReadWrite:
                    return "read-write";
                case Access.WriteOnly:
                    return "write-only";
                case Access.ReadCreate:
                    return "read-create";
                case Access.NotAccessible:
                    return "not-accessible";
                case Access.AccessibleForNotify:
                    return "accessible-for-notify";
                case Access.NotImplemented:
                    return "not-implemented";
                default:
                    throw new ArgumentOutOfRangeException(nameof(access));
            }
        }
    }
}
